package co.blocke.scalajack2
package codec.classes

trait ScalaClassCodec[T](implicit codecCache: CodecCache): // extends ClassTypeAdapterBase[T]:
  val typeMembersByName:  Map[String, TypeMemberInfo]
  // dbCollectionName:   Option[String]

  private val classInfo = info.asInstanceOf[ClassInfo]

  val isSJCapture = classInfo.hasMixin(SJ_CAPTURE)

  def _read_createInstance(args: List[Object], foundBits: mutable.BitSet, captured: java.util.HashMap[String, _]): T
  def _read_updateFieldMembers( fmbn: Map[String, ClassFieldMember[_,_]]): ScalaClassTypeAdapter[T]

  def read(parser: Parser): T =
    if (parser.peekForNull) then
      null.asInstanceOf[T]
    else
      // External type hint --> Substitute type field's type into the placeholder (i.e.'T') in the class' fields
      val (foundBits, args, captured) = {
        if (classInfo.typeMembers.nonEmpty) then
          val fixedFields = findActualTypeMemberTypes(parser)  // Resolve actual type of type member (should be a class) and substitute any fields having that type with the actual
          val substitutedClassInfo = _read_updateFieldMembers(fixedFields)
          parser.expectObject(substitutedClassInfo, taCache.jackFlavor.defaultHint)
        else
          parser.expectObject(this, taCache.jackFlavor.defaultHint)
      }

      val testBits = fieldBitsTemplate.collect{
        case b if !foundBits.contains(b) => b
      }
      if (testBits.isEmpty) then
        _read_createInstance(args, foundBits, captured)
      else
        parser.backspace()
        throw new ScalaJackError(
          parser.showError(
            s"Class ${classInfo.name} missing required fields: " + testBits
              .map(b => orderedFieldNames(b))
              .mkString(", ")
          )